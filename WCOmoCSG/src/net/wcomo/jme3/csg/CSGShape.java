/** Copyright (c) 2011 Evan Wallace (http://madebyevan.com/)
 	Copyright (c) 2003-2014 jMonkeyEngine
	Copyright (c) 2015, WCOmohundro
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted 
	provided that the following conditions are met:

	1. 	Redistributions of source code must retain the above copyright notice, this list of conditions 
		and the following disclaimer.

	2. 	Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
		and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	3. 	Neither the name of the copyright holder nor the names of its contributors may be used to endorse 
		or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED 
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
	PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR 
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
	LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
	IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
	Logic and Inspiration taken from https://github.com/andychase/fabian-csg 
	and http://hub.jmonkeyengine.org/users/fabsterpal, which apparently was taken from 
	https://github.com/evanw/csg.js
**/
package net.wcomo.jme3.csg;

import java.io.IOException;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.List;

import com.jme3.export.InputCapsule;
import com.jme3.export.JmeExporter;
import com.jme3.export.JmeImporter;
import com.jme3.export.OutputCapsule;
import com.jme3.export.Savable;
import com.jme3.math.Transform;
import com.jme3.math.Vector2f;
import com.jme3.math.Vector3f;
import com.jme3.scene.Geometry;
import com.jme3.scene.Mesh;
import com.jme3.scene.VertexBuffer.Type;
import com.jme3.scene.mesh.IndexBuffer;
import com.jme3.material.Material;
import com.jme3.material.MatParamTexture;
import com.jme3.texture.Texture;
import com.jme3.util.BufferUtils;

/** Provide a basic 'shape' for CSG processing 
 
 	A CSG Shape is based on a generated set of polygons that describe the faces of the shape
 	(think Mesh for the CSG world).  Any shape can be CSG blended with another shape via
 	union, difference, and intersection.  The result is a new CSG Shape with its own set of 
 	polygons.
 	
 	The basic Shape can be generated by a supplied list of Polygons, but externally, it is
 	based on a JME shape, like a Box, Sphere, Cylinder, ...
 	In such a case, the polygons are built from the Mesh behind the JME Shape.
 	
 	The CSGShape acts like a Geometry so that transformations can be applied to the shape
 	before any CSG blending occurs.  I do not believe that Geometry based lights are of
 	use at this level, but it would be interesting to think of per-shape based 
 	textures/materials.
 */
public class CSGShape 
	extends Geometry
	implements Comparable<CSGShape> 
{
	/** Canned, immutable empty list of polygons */
	protected static final List<CSGPolygon> sEmptyPolygons = new ArrayList<CSGPolygon>(0);
	
	/** The list of polygons that make up this shape */
	protected List<CSGPolygon>			mPolygons;
	/** The operator applied to this shape as it is added into the geometry */
	protected CSGGeometry.CSGOperator	mOperator;
	/** Arbitrary 'ordering' of operations within the geometry */
	protected int						mOrder;

	
	/** Basic null constructor */
	public CSGShape(
	) {
		this( sEmptyPolygons, 0 );
	}
	/** Constructor based on a mesh */
	public CSGShape(
		String	pShapeName
	,	Mesh	pMesh
	) {
		this( pShapeName, pMesh, 0 );
	}
	public CSGShape(
		String	pShapeName
	,	Mesh	pMesh
	,	int		pOrder
	) {
		super( pShapeName, pMesh );
		mPolygons = sEmptyPolygons;
		mOrder = pOrder;
		mOperator = CSGGeometry.CSGOperator.UNION;
	}
	/** Constructor based on an explicit list of polygons */
	protected CSGShape(
		List<CSGPolygon>	pPolygons
	,	int					pOrder
	) {
		super( null );
		mPolygons = pPolygons;
		mOrder = pOrder;
		mOperator = CSGGeometry.CSGOperator.UNION;
	}
		
	/** Make a copy of this shape */
	@Override
	public CSGShape clone(
	) {
		CSGShape aClone;
		
		if ( this.mesh == null ) {
			// NOTE that a shallow copy of the immutable polygons is acceptable
			List<CSGPolygon> newPolyList = new ArrayList<CSGPolygon>( mPolygons );
			aClone = new CSGShape( newPolyList, mOrder );
		} else {
			// Base it on the mesh
			aClone = (CSGShape)super.clone();
			aClone.setOrder( mOrder );
		}
		aClone.setOperator( mOperator );
		return( aClone );
	}
	
	/** Accessor to the list of polygons */
	public List<CSGPolygon> getPolygons(
	) { 
		if ( mPolygons.isEmpty() && (this.mesh != null) ) {
			mPolygons = fromMesh( this.mesh, this.getLocalTransform() );
		}
		return mPolygons; 
	}
	
	/** Accessor to the operator */
	public CSGGeometry.CSGOperator getOperator() { return mOperator; }
	public void setOperator(
		CSGGeometry.CSGOperator	pOperator
	) {
		mOperator = pOperator;
	}
	
	/** Accessor to the order of operations */
	public int getOrder() { return mOrder; }
	public void setOrder(
		int		pOrder
	) {
		mOrder = pOrder;
	}

	/** Add a shape into this one */
	public CSGShape union(
		CSGShape	pOther
	) {
		CSGPartition a = new CSGPartition( getPolygons() );
		CSGPartition b = new CSGPartition( pOther.getPolygons() );
		a.clipTo(b);
		b.clipTo(a);
		b.invert();
		b.clipTo(a);
		b.invert();
		a.buildHierarchy( b.allPolygons( null ), 0 );
		return( new CSGShape( a.allPolygons( null ), this.getOrder() ));
	}
	
	/** Subtract a shape from this one */
	public CSGShape difference(
		CSGShape	pOther
	) {
		CSGPartition a = new CSGPartition( getPolygons() );
		CSGPartition b = new CSGPartition( pOther.getPolygons() );
		a.invert();
		a.clipTo(b);
		b.clipTo(a);
		b.invert();
		b.clipTo(a);
		b.invert();
		a.buildHierarchy( b.allPolygons( null ), 0 );
		a.invert();
		return( new CSGShape( a.allPolygons( null ), this.getOrder() ));
	}

	/** Find the intersection with another shape */
	public CSGShape intersection(
		CSGShape	pOther
	) {
		CSGPartition a = new CSGPartition( getPolygons());
	    CSGPartition b = new CSGPartition( pOther.getPolygons() );
	    a.invert();
	    b.clipTo(a);
	    b.invert();
	    a.clipTo(b);
	    b.clipTo(a);
	    a.buildHierarchy( b.allPolygons( null ), 0 );
	    a.invert();
		return( new CSGShape( a.allPolygons( null ), this.getOrder() ));
	}

	/** Produce the set of polygons that correspond to a given mesh */
	protected List<CSGPolygon> fromMesh(
		Mesh		pMesh
	,	Transform	pTransform
	) {
		// Convert the mesh in to appropriate polygons
		IndexBuffer idxBuffer = pMesh.getIndexBuffer();
		FloatBuffer posBuffer = pMesh.getFloatBuffer(Type.Position);
		FloatBuffer normBuffer = pMesh.getFloatBuffer(Type.Normal);
		FloatBuffer texCoordBuffer = pMesh.getFloatBuffer(Type.TexCoord);
		
		// Work from 3 points which define a triangle
		List<CSGPolygon> polygons = new ArrayList<CSGPolygon>( idxBuffer.size() / 3 );
		for (int i = 0; i < idxBuffer.size(); i += 3) {
			int idx1 = idxBuffer.get(i);
			int idx2 = idxBuffer.get(i + 1);
			int idx3 = idxBuffer.get(i + 2);
			
			// Extract the positions
			Vector3f pos1 = new Vector3f(posBuffer.get(idx1 * 3), posBuffer.get((idx1 * 3) + 1), posBuffer.get((idx1 * 3) + 2));
			Vector3f pos2 = new Vector3f(posBuffer.get(idx2 * 3), posBuffer.get((idx2 * 3) + 1), posBuffer.get((idx2 * 3) + 2));
			Vector3f pos3 = new Vector3f(posBuffer.get(idx3 * 3), posBuffer.get((idx3 * 3) + 1), posBuffer.get((idx3 * 3) + 2));

			// Extract the normals
			Vector3f norm1 = new Vector3f(normBuffer.get(idx1 * 3), normBuffer.get((idx1 * 3) + 1), normBuffer.get((idx1 * 3) + 2));
			Vector3f norm2 = new Vector3f(normBuffer.get(idx2 * 3), normBuffer.get((idx2 * 3) + 1), normBuffer.get((idx2 * 3) + 2));
			Vector3f norm3 = new Vector3f(normBuffer.get(idx3 * 3), normBuffer.get((idx3 * 3) + 1), normBuffer.get((idx3 * 3) + 2));

			// Extract the Texture Coordinates
			Vector2f texCoord1 = new Vector2f(texCoordBuffer.get(idx1 * 2), texCoordBuffer.get((idx1 * 2) + 1));
			Vector2f texCoord2 = new Vector2f(texCoordBuffer.get(idx2 * 2), texCoordBuffer.get((idx2 * 2) + 1));
			Vector2f texCoord3 = new Vector2f(texCoordBuffer.get(idx3 * 2), texCoordBuffer.get((idx3 * 2) + 1));
			
			// Construct the vertices that define the points of the triangle
			List<CSGVertex> aVertexList = new ArrayList<CSGVertex>( 3 );
			aVertexList.add( new CSGVertex( pos1, norm1, texCoord1, pTransform ) );
			aVertexList.add( new CSGVertex( pos2, norm2, texCoord2, pTransform ) );
			aVertexList.add( new CSGVertex( pos3, norm3, texCoord3, pTransform ) );
			
			// And build the appropriate polygon
			CSGPolygon aPolygon = new CSGPolygon( aVertexList );
			polygons.add( aPolygon );
		}
		return( polygons );
	}
	
	/** Produce the mesh that corresponds to this shape */
	public Mesh toMesh(
	) {
		Mesh aMesh = new Mesh();
		
		List<CSGPolygon> aPolyList = getPolygons();
		int anEstimateVertexCount = aPolyList.size() * 3;
		
		List<Vector3f> aPositionList = new ArrayList<Vector3f>( anEstimateVertexCount );
		List<Vector3f> aNormalList = new ArrayList<Vector3f>( anEstimateVertexCount );
		List<Vector2f> aTexCoordList = new ArrayList<Vector2f>( anEstimateVertexCount  );
		List<Integer> anIndexList = new ArrayList<Integer>( anEstimateVertexCount );
		
		// Walk the list of all polygons, collecting all vertices
		int indexPtr = 0;
		for( CSGPolygon aPolygon : aPolyList ) {
			List<CSGVertex> aVertexList = aPolygon.getVertices();
			int aVertexCount = aVertexList.size();
			
			List<Integer> vertexPointers = new ArrayList<Integer>( aVertexCount );
			for( CSGVertex aVertex : aVertexList ) {
				aPositionList.add( aVertex.getPosition() );
				aNormalList.add( aVertex.getNormal() );
				aTexCoordList.add( aVertex.getTextureCoordinate() );
				
				vertexPointers.add( indexPtr++ );
			}
			for( int ptr = 2; ptr < aVertexCount; ptr += 1 ) {
				anIndexList.add( vertexPointers.get(0) );
				anIndexList.add( vertexPointers.get(ptr-1) );
				anIndexList.add( vertexPointers.get(ptr) );
			}
		}
		// Populate the appropriate mesh buffers (which are based on arrays)
		Vector3f[] positionArray = aPositionList.toArray( new Vector3f[aPositionList.size()] );
		Vector3f[] normalArray = aNormalList.toArray( new Vector3f[aNormalList.size()] );
		Vector2f[] texCoordArray = aTexCoordList.toArray( new Vector2f[aTexCoordList.size()] );
		int[] indicesIntArray = new int[ anIndexList.size()];
		for(int i = 0, j = anIndexList.size(); i < j; i += 1 ) {
			indicesIntArray[i] = anIndexList.get(i);
		}
		aMesh.setBuffer( Type.Position, 3, BufferUtils.createFloatBuffer(positionArray));
		aMesh.setBuffer( Type.Normal, 3, BufferUtils.createFloatBuffer(normalArray));
		aMesh.setBuffer( Type.Index, 3, BufferUtils.createIntBuffer(indicesIntArray));
		aMesh.setBuffer( Type.TexCoord, 2, BufferUtils.createFloatBuffer(texCoordArray));
		aMesh.updateBound();
		aMesh.updateCounts();
		
		return( aMesh );
	}

	
	/** Make this shape 'savable' */
	@Override
	public void write(
		JmeExporter		pExporter
	) throws IOException {
		// Let the geometry do its thing
		super.write( pExporter );
		
		OutputCapsule capsule = pExporter.getCapsule( this );
		capsule.write( mOrder, "Order", 0 );
		capsule.write( mOperator, "Operator", CSGGeometry.CSGOperator.UNION );
		if ( this.mesh == null ) {
			// If not based on a Mesh, then preserve the given polygons
			// NOTE a deficiency in the OutputCapsule API which should operate on a List,
			//		but instead requires an ArrayList
			capsule.writeSavableArrayList( (ArrayList<CSGPolygon>)mPolygons
											, "Polygons"
											, (ArrayList<CSGPolygon>)sEmptyPolygons );
		}
	}

	@Override
	public void read(
		JmeImporter		pImporter
	) throws IOException {
		// Let the geometry do its thing
		super.read( pImporter );
		
		InputCapsule aCapsule = pImporter.getCapsule(this);
		mOrder = aCapsule.readInt( "Order", 0 );
		mOperator = aCapsule.readEnum( "Operator", CSGGeometry.CSGOperator.class, CSGGeometry.CSGOperator.UNION );
		if ( this.mesh == null ) {
			// If not based on a mesh, then restore via the polygons
			mPolygons = (List<CSGPolygon>)aCapsule.readSavableArrayList( "Polygons"
																	, (ArrayList<CSGPolygon>)sEmptyPolygons );
		} else {
	        // Extended attributes
	        Vector2f aScale = (Vector2f)aCapsule.readSavable( "scaleTexture", null );
	        if ( aScale != null ) {
	        	this.mesh.scaleTextureCoordinates( aScale );
	        }
	        boolean repeatTexture = aCapsule.readBoolean( "repeatTexture", false );
	        if ( repeatTexture && (this.material != null)) {
	        	MatParamTexture aParam = this.getMaterial().getTextureParam( "DiffuseMap" );
	        	if ( aParam != null ) {
	        		aParam.getTextureValue().setWrap( Texture.WrapMode.Repeat );
	        	}
	        }
		}
	}
	
	/** Implement Comparable to enforce an appropriate application of operations */
	@Override
	public int compareTo(
		CSGShape	pOther
	) {
		int thisOrder = this.getOrder(), otherOrder = pOther.getOrder();
		
		if ( thisOrder == otherOrder ) {
			// CSG should be applied inner-level as follows: Union -> Intersection -> Difference
			switch( this.getOperator() ) {
			case UNION:
				switch( pOther.getOperator() ) {
				case UNION: return( 0 );		// Same as other UNION
				default: return( -1 );			// Before all others
				}
				
			case INTERSECTION:
				switch( pOther.getOperator() ) {
				case UNION: return( 1 );		// After UNION
				case INTERSECTION: return( 0 );	// Same as other INTERSECTION
				default: return( -1 );			// Before all others
				}
				
			case DIFFERENCE:
				switch( pOther.getOperator() ) {
				case UNION:
				case INTERSECTION: 
					return( 1 );				// After UNION/INTERSECTION
				case DIFFERENCE: return( 0 );	// Same as other DIFFERENCE
				default: return( -1 );			// Before all others
				}
				
			case SKIP:
				switch( pOther.getOperator() ) {
				case SKIP: return( 0 );			// Same as other SKIP
				default: return( 1 );			// After all others
				}
			}
			// If we fall out the above, then we come before
			return( -1 );
		}
		return( thisOrder - otherOrder );
	}

}
